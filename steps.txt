# pseudo-code for ERay-Simplicity control mechanisms
on-start:
    check engines
    check flaperons
    check instruments
    check sensors
    check navigation
    check controls
    unlock controls
on-takeoff:
    while in-takeoff:
        vec3 joystick-input = get(input.stick)
        set plane-out = calc-motor-outputs(joystick-input, plane-context)
        if get(input.landing-gear):
            run retract-landing-gear // I don't remember if it actually has a retractable landing gear
    end
    if cruising-altitude:
        load flight-plan
        run flight-plan
        run control-sleep //only for the actual plane, to avoid accidently bumping the controls considering a joystick is not difficult to move. Will not accept input until the input goes past a threshold

struct PlaneOutput{
    vec4 motors;
    vec2 flaperons;

}
on-input:
    vec3 joystick-input = clamp-input(get(input.stick)) //clamp may actually just be a scaling
    PlaneOutput output = calc-motor-outputs(joystick-input, plane-context) //plane-context contains all sensor data and any other data required to calculate a safe output for the plane
    //insert safety measures here (additional cases for if the number of motors decreases)
    set plane = output

calc-motor-outputs(vec3 input, PlaneCtx context){
    vec3 velocity = calculate_raw_velocity(input, context)
    if not safety:
       goto motors 
    float magnitude = velocity.magnitude()
    magnitude = min(magnitude, adjusted_stall_speed) / magnitude
    velocity = magnitude * velocity
motors:
    mat4x4 motors = get motors
    mat4x4 motors_output = calculate_motors_power(motors, velocity)
    PlaneCtx new_context = calculate_periph_motion(velocity, input, context)

    if errors:
       throw error
       return get(current_velocity)
    set context = new_context
    set motors = motors_output
}

    

    
    
